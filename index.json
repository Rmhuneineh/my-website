[{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Shaft Profile Definition. Static and fatigue verification for shaft design.","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Outline Hello and welcome to the second part of this tutorial series. In the previous part, we learnt how to: install PyGRITbx along with the tools required to work with it define components that constitute a given gearbox define interactions between components calculate the forces exchanged between said components and the reaction forces produced by the bearings. In this part, we will take the results from Part 1 to: define a shaft profile based on the given technical drawing calculate and plot internal loads and stresses on the defined shaft profile perform static and fatigue verification by calculating the corresponding safety factors. The code blocks present in this part can be executed ONLY if the code blocks from the previous part have been executed already within a currently active Jupyter session. Therefore, make sure you add these blocks to the file created in the first part. Without further talk, let’s get down to business. ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:1:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Shaft Profile Recall the configuration of the gearbox from Figure 1. Figure 1 - Gearbox Assembly Our goal is to define the profile of shaft A2 to be able to calculate the internall stresses along the axis of the shaft after having computed the internal loads. To achieve this, we refer to the technical drawing of shaft A2 as portrayed in Figure 2. Figure 2 - Shaft A2 Technical Drawing ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:2:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Locating Corners To define the shaft profile, we would need to know the radius of the shaft at every cross-section along its axis. Using the radius and axial location, we can specify the coordinates of certain points that we can locate on the technical drawing. These points would be the corners that define a radius change along the shaft’s axis. For example, since A2 rotates around the z-axis and this axis is pointing to the right, we start from the left most part of the shaft by locating the 4 points shown in Figure 3. Figure 3 - Shaft A2 First Corners - P1 It’s clear that corner P1 is located at location 0 [mm] along the shaft’s axis. What about the radius at which this corner is located? We can tell from section D-D (Figure 2) that the diameter corresponds to the notation M 35. This means that the diameter is equal to 35 [mm]; thus, corresponding to a 17.5 [mm] radius. However, this is true regarding corners P2 and P3 but not P1 since there’s a chamfer to get from corner P1 to corner P2. The chamfer is specified to be of size 1 [mm]. This means that corner P1 is located at a radius equal to 16.5 [mm]. Therefore, P1 is located at $\\rArr (0, 16.5)$. - P2 Due to the chamfer, the axial location of corner P2 is equal to 1 [mm]. The diameter at which it’s located has been explained earlier and is equal to 35 [mm]. Therefore, P2 is located at $\\rArr (1, 17.5)$. - P3 Corner P3 is located along the same radius as corner P2. The axial location however can be seen as a dimension on the technical drawing set to 46 [mm]. However, since corner P4 is also located at that axial location, we will offset corner P3 by 0.1 [mm] to the left so as to locate it axially at 45.9 [mm]. Therefore, P3 is located at $\\rArr (45.9, 17.5)$. - P4 The axial location of corner P4 is 46 [mm] as specified by the axial dimension on the technical drawing. The diameter is also shown, 40 [mm], corresponding to a radius equal to 20 [mm]. Therefore, P4 is located at $\\rArr (46, 20)$. By continuing in this manner, we can define 2 numpy arrays: the first specifying all the points’ axial locations and, the second, all their corresponding radii as shown in the following code block: # Define Radii and Axial Locations radii = np.array([33, 35, 35, 40, 40, 34, 34, 32, 32, 31]) / 2 alocs = np.array([ 0, 1, 45.9, 46, 132.9, 133, 158.4, 158.5, 222, 223]) To define and check the profile, you can run the following code: # Define a Shaft Profile for Trial trial = pgt.ShaftProfile(name=\"trial\", radii=radii, locs=alocs) # Plot Defined Profile trial.plotProfile() This should produce the plot seen in Figure 4. Figure 4 - Shaft A2 Trial Profile I would be more than happy to inform you that this is almost all it takes to define the general profile of the shaft. However, it’s specified in this project that for static verification, sections where there’s a keyseat should be considered with a diameter equal to the nominal diameter stated in the technical drawing minus the depth of the keyseat! Hence, this requirement presents us with new corners and the proper radii and locations should be defined as follows: # Define Radii and Axial Locations with Keyseats static_radii = np.array([33, 35, 35, 30, 30, 35, 35, 40, 40, 34, 34, 32, 32, 27, 27, 32, 32, 31]) / 2 static_alocs = np.array([ 0, 1, 11.9, 12, 39.9, 40, 45.9, 46, 132.9, 133, 158.4, 158.5, 178.4, 178.5, 208.4, 208.5, 222, 223]) We can then define and plot the static_profile similar to the previous definition of the trial profile. # Define a Shaft Profile for Static Verification static_profile = pgt.ShaftProfile(name=\"Static Profile\", radii=static_radii, locs=static_alocs) # Plot Defined Profile static_profile.plotProfile() This will procduce the profile shown in Figure 5. Figure 5 - Shaft A2 Static Profile ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:2:1","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Refinements and Fillets Our current definition of the shaft profile is coarse. This means that any calculations performed along the shaft’s axis won’t be distributed properly along the axis but only on those corners that we have defined earlier. We need a fine profile with more points interpolated between the defined corners to have a precise representation of the profile whenever we need it to perform certain calculations along its axis. Luckily, PyGRITbx has the feature that refines a profile based on a given delta separating one point from another along the shaft’s axis. Small values of delta allow for a finer profile with more precise calculations at the cost of memory and speed. By default, delta is set to 0.1 [mm]. To refine the profile, use the code in the following block: # Refine Static Profile static_profile_refined = static_profile.refineProfile(delta=0.1) Now that we have a refined profile, we can add fillets as shown in the technical drawing. Why are fillets important? Because stresses are calculated based on the cross-sectional properties. If we don’t take into consideration the change in those properties due to the change in diameter caused by the fillets, we would be missing out on valuable information regarding how the trend of these stresses changes along the shaft’s axis. To define a fillet, we need the following information: radius: this is simply the radius of the fillet and must be in [mm] zOff: this is the axial location of the center of the circle the fillet is part of ([mm]) dOff: this is the radial location of the center of the circle the fillet is part of ([mm]) quadrant: an array specifying one or more quadrants of the circle the fillet is part of (Figure 6) Figure 6 - Fillet Quadrants From detail F-F in Figure 2, we can see that there’s a fillet of radius 1 [mm] belonging to quadrant 2 at an axial location equal to 45 [mm] and a radial location equal to 18.5 [mm]. Therefore we can simply add this fillet to the static profile using the following piece of code: # Add First Fillet to Static Profile static_profile_refined.addFillet(radius=1, quadrant=[2], zOff=45, dOff=18.5) Similarly we can locate the second fillet shown in detail G-G except that this one belongs to qudrant 1: # Add Second Fillet to Static Profile static_profile_refined.addFillet(radius=1, quadrant=[1], zOff=134, dOff=18) Finally, we can add the profile to the shaft object: # Add Static Profile to Shaft A2 A2.addProfile(profile=static_profile_refined) ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:2:2","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Shaft Sections The last step before proceeding with static analysis is defining the shaft sections. These are the given sections in the techinal drawing: V1, V2, and V3. Sections are imperative to locate potentially critical locations at which you might suspect the component to fail (in this case the shaft). Moreover, we can include in the analysis the notch sensitivity and geometrical stress concentration factors on said sections to consider material properties, surface finish, and the topology of the shaft! Defining a section is a relatively easy task in PyGRITbx. All you need is: name: to act as a label when plotting loc: axial location of the section along the shaft’s rotational axis d: the diameter of the shaft at the specified section Ra: surface roughness of the shaft at the specified section material: the material of the shaft - V1 Therefore, to define section V1, you execute the following: # Section V1 Definition V1 = pgt.ShaftSection(name=\"V1\", loc=26, d=30, Ra=0.8, material=shaftMaterial) Note that section V1 is in the middle of a keyseat. In the project description, it’s specified that the stress concentration raiser $\\mathbf{K_f}$ is equal to 1.6 for Bending Load and equal to 2.0 for *Torsional Load. Therefore, in addition to the section definition we need to execute the following: # Section V1 Stress Concentration Raiser V1.appendKf(Kf=np.array([1.6, 2.0]), loadType=np.array([\"Bending\", \"Torsion\"])) - V2 Similarly, we can define section V2: # Section V2 Definition V2 = pgt.ShaftSection(name=\"V2\", loc=46, d=40, Ra=0.8, material=shaftMaterial) Given that there’s a fillet and a shoulder at section V2, we’d need to define the characteristics of the notch sensitivity as well as the geometric stress raiser. This is simply done as shown in the following block: # Section V2 Notch Sensitivity and Geometric Stress Rasier V2.addNotchSensitivity(notchRadius=1, sigma_u=shaftMaterial.sigma_u) V2.addGeometricStressRaiser(r2d=1/35, D2d=40/35) For the notch sensitivity $\\mathbf{q}$, PyGRITbx uses the graph shown in Figure 7 to get the proper value. Figure 7 - Notch Sensitivity Graph For the geometric stress concentration factor $\\mathbf{K_t}$, the toolbox uses the set of graphs in Figure 8 to get the proper value for each type of load. Figure 8 - Geometric Stress Concentration Factor Graph The geometric stress raiser is then calculated according to the following equation: $$ K_f = 1 + q * (K_t - 1) $$ - V3 Similar to section V2, section V3 is defined along with a notch sensitivity and a geometric stress raiser. # Section V3 Definition V3 = pgt.ShaftSection(name=\"V3\", loc=133, d=40, Ra=0.8, material=shaftMaterial) # Section V3 Notch Sensitivity and Geometric Stress Raiser V3.addNotchSensitivity(notchRadius=1, sigma_u=shaftMaterial.sigma_u) V3.addGeometricStressRaiser(r2d=1/34, D2d=40/34) Once all sections are properly defined, we can proceed by adding them to the shaft they belong to. # Add Sections to Shaft A2 userSections = np.array([V1, V2, V3]) A2.addSections(sections=userSections) ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:3:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Static Verification At this point, the shaft profile has been defined and the proper sections along its axis have been located with their corresponding characteristics. Now, we can proceed by performing the static verification on the shaft. To do that we simply call the function .performStaticVerification() on the shaft object. PyGRITbx will then proceed to calculate the internal loads along the axis of the shaft and will ask you whether you want to plot them. Answer y if you want them to be plotted (this is the case here). The toolbox will then calculate the internal stresses along the shaft’s axis based on the cross-sectional properties and the previously calculated internal loads. It will then ask you whether you would like to plot these stresses; answer y if you want them to be plotted (again, this is the case here). You can simply answer n if you don’t want the internal loads or the internal stresses to be plotted. # Perform Static Verification on Shaft A2 A2.performStaticVerification(RF=RF, profile=A2.profiles[0]) Executing the code above and answering y on the 2 prompts will produce 10 graphs: 5 with internal loads and 5 with their corresponding internal stresses. For brevity I will only show you 1 of each as an example. In Figure 9, you can see the bending moment $\\mathbf{M_B(z)}$ which is the resultant bending moment between the x-axis and the y-axis components. Figure 9 - Bending Moment Plot In Figure 10, you can see the equivalent stress plot $\\boldsymbol{\\sigma_{id}(z)}$ which is calculated according to the resultant normal stress and torsional stress. Figure 10 - Equivalent Stress Plot After all the plots, the output message shows the calculated static safety factor at each cross section as shown in Figure 11. Figure 11 - Static Safety Factor ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:4:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Fatigue Verification To perform the fatigue verification, we follow the same procedure as that of the static verification: define a profile (if not already defined) define sections of interest with their corresponding characteristics (if not already defined) calculate and plot new stresses based on this profile (internal loads don’t change but internal stresses do) calculate mean and alternating stresses for sections of interest and plot them on the Haigh Diagram calculate the fatigue safety factor for each section of interest We already defined the proper fatigue profile by the way. It’s actually the trial profile presented earlier because it’s specified in the project description that for keyseats, the diameter remains the same! Therefore, we will simply copy/paste the previous code block for defining the trial profile and change the name accordingly: # Define Radii and Axial Locations radii = np.array([33, 35, 35, 40, 40, 34, 34, 32, 32, 31]) / 2 alocs = np.array([ 0, 1, 45.9, 46, 132.9, 133, 158.4, 158.5, 222, 223]) # Define a Shaft Profile for Fatigue Verification fatigue_profile = pgt.ShaftProfile(name=\"Fatigue Profile\", radii=radii, locs=alocs) # Refine Fatigue Profile fatigue_profile_refined = fatigue_profile.refineProfile(delta=0.1) # Add First Fillet to Fatigue Profile fatigue_profile_refined.addFillet(radius=1, quadrant=[2], zOff=45, dOff=18.5) # Add Second Fillet to Fatigue Profile fatigue_profile_refined.addFillet(radius=1, quadrant=[1], zOff=134, dOff=18) # Add Fatigue Profile to Shaft A2 A2.addProfile(profile=fatigue_profile_refined) # Modify Diameter for First Section Accordingly A2.sections[0].d = 35 userSections[0].d = 35 Notice that in the last lines we modify the diameter of the first section that is present on the keyseat since for the fatigue profile the diameter is actually different. Other than that, we simply reproduced what we’ve done before for the static verification profile. At this point, we can simply proceed with the fatigue verfication. As you might’ve guessed, we would simply call the .performFatigueVerification() function on the shaft object A2. # Perform Fatigue Verification on Shaft A2 A2.performFatigueVerification(RF=RF, profile=A2.profiles[1]) Running this will result in 3 prompts in the following order: Do internal loads need to plotted: in this case, not necessarily because we’ve already plotted them on the static profile and they won’t change Do internal stresses need to plotted: yes because, even though the internal loads didn’t change, the cross-sectional properties along the axis of the shaft changed indeed and this will result in slightly different trends Do the Haigh Diagrams need to be plotted: yes because it’s required in the project description and it is of interest to see the operating point at each cross-section In Figure 12, you can see an example of the Haigh Diagram for section V1 where the purple asterisk represents the operating point. Figure 12 - Haigh Diagram Example The final output after the plots is the calculated fatigue safety factor at the interested sections as shown in Figure 13. Figure 13 - Fatigue Safety Factor With this, we mark the finish of this part of the tutorial! ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:5:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Tips, Tricks, and Final Remarks Eventhough we were able to perform the static and fatigue verification of the shaft A2, the project description asks for a bit more. Yes, the toolbox is able to present you with beautiful plots of the internal loads, internal stresses, and Haigh Diagrams which are required; however, the project asks also for alternating and mean stresses for every cross section as well as the stress concentration factors, fatigue limit correction factors, fatigue limit correction for the component, and the equivalent alternating and mean stresses. The latter requirements are calculated by the toolbox automatically but one needs to know how to extract this information so I’ll give you examples of each. ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:6:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Alternating and Mean Stresses For every section of interest, the alternating and mean stresses are calculated automatically by the toolbox. To extract this information, refer to the following example applied on section V1. # Section V1: Alternating and Mean Stress # Normal Stress print(f\"Mean Normal Stress: {V1.sigma_m_N:.3} [MPa]\") print(f\"Alternating Normal Stress: {V1.sigma_a_N:.3} [MPa]\") # Output # Mean Normal Stress: 1.26 [MPa] # Alternating Normal Stress: 0.0 [MPa] # Bending Stress print(f\"Mean Bending Stress: {V1.sigma_m_Mb:.3} [MPa]\") print(f\"Alternating Bending Stress: {V1.sigma_a_Mb:.3} [MPa]\") # Output # Mean Bending Stress: 0.0 [MPa] # Alternating Bending Stress: 95.1 [MPa] # Torsional Stress print(f\"Mean Torsional Stress: {V1.tau_m_Mt:.3} [MPa]\") print(f\"Alternating Torsional Stress: {V1.tau_a_Mt:.3} [MPa]\") # Output # Mean Torsional Stress: 26.9 [MPa] # Alternating Torsional Stress: 0.0 [MPa] ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:6:1","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Stress Concentration Factors Applying the same concept on the stress concentration factors for the section V2, we can execute the following: # Section V2: Stress Concentration Factors # Notch Sensitivity print(f\"Notch Sensitivity: {V2.q.qReq:.2} [-]\") # Output # Notch Sensitivity: 0.88 [-] # Normal Stress Concentration Factor and Raiser print(f\"Normal Stress Concentration Factor: {V2.Kt_N:.3} [-]\") print(f\"Normal Stress Concentration Raiser: {V2.Kf_N:.3} [-]\") # Output # Normal Stress Concentration Factor: 2.24 [-] # Normal Stress Concentration Raiser: 2.1 [-] # Bending Stress Concentration Factor and Raiser print(f\"Bending Stress Concentration Factor: {V2.Kt_B:.3} [-]\") print(f\"Bending Stress Concentration Raiser: {V2.Kf_B:.3} [-]\") # Output # Bending Stress Concentration Factor: 2.25 [-] # Bending Stress Concentration Raiser: 2.1 [-] # Torsional Stress Concentration Factor and Raiser print(f\"Torsional Stress Concentration Factor: {V2.Kt_T:.3} [-]\") print(f\"Torsional Stress Concentration Raiser: {V2.Kf_T:.3} [-]\") # Output # Torsional Stress Concentration Factor: 1.62 [-] # Torsional Stress Concentration Raiser: 1.55 [-] ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:6:2","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Fatigue Limit Correction Factors Now let’s take a look at how we can extract information about the fatigue limit correction factors for size effect and surface finish effect by applying it on section V3: # Section V3: Fatigue Limit Correction Factors # Size Effect print(f\"C_s = {V3.FLCF.Cs_req:.3} [-]\") # Output # C_s = 0.845 [-] # Surface Finish Effect print(f\"C_f = {V3.FLCF.Cf_req:.3} [-]\") # Output # C_f = 1.0 [-] ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:6:3","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Fatigue Limit Correction for Shaft A2 We can simply print the calculated corrected fatigue limit of shaft A2 by retrieving it from the material properties of the shaft using the following code snippet: # Fatigue Limit Correction on Shaft A2 print(f\"Corrected Fatigue Limit: {A2.material.sigma_Dm1C:.4} [MPa]\") # Output # Corrected Fatigue Limit: 307.6 [MPa] ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:6:4","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Final Words To sum up, in this tutorial we took the forces calculated in Part 1 and used them to calculate and plot the internal loads acting on shaft A2. By defining the profile of shaft A2, we implicitly defined the cross-sectional properties across the shaft’s axis and used that information to calculate and plot the internal stresses acting on the shaft. We then specified which sections are of interest to limit the static and fatigue safety factors calculation to those sections only. In the 3rd and last part, we will perform bending and wear analysis on gears R1 and R3 as well as bearing life analysis on all the bearings! ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:7:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"References Richard G. Budynas and J. Keith Nisbett, Shigley’s Mechanical Engineering Design, McGraw-Hill, 2006. SKF Group, SKF Rolling Bearings Catalogue, SKF. SKF Rolling Bearings ","date":"2026-02-15","objectID":"/posts/pygritbx_tutorial2/:8:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 2: No Pain No Gain, No Stress No Strain","uri":"/posts/pygritbx_tutorial2/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Gearbox configuration definition. Calculating forces.","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Outline This blog post is the first part of a 3-part series. In this series, I would like to introduce you to my python toolbox with a tutorial based on a project given to mechanical engineering students following the course “02SXJJM - Fundamentals of Machine Design” at Politecnico di Torino. My best hope is that this series would serve as a guide for the reader in future projects concerning geargbox design validation. In this part, you will learn how to: Install the toolbox along with the necessary tools. Define the components inside the gearbox as python objects. Configure the interactions between different components via shafts and meshes. Calculate the reaction forces on the bearings based on the given operating point. Please feel free to contribute by sharing your thoughts regarding either the tutorial itself, the toolbox, or both. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:1:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Prerequisites To follow this series, it’s expected that the reader: has studied applied mechanics (or the like) has basic programming skills (python is used here) is aware of engineering terms like: stress, static and fatigue verification, safety factor, stress concentration factors, Haigh diagram is using Visual Studio Code with Jupyter and Pylance extensions installed ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:1:1","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"What is PyGRITbx? Python-based Gearbox Realiability and Integriy Toolbox assists mechanical engineering students (or even engineers) working on the design verification of a gearbox. Given an operating point as a boundary condition, the toolbox calculates the loads on the components constituting the gearbox (gears, shafts, and bearings), and verifies the design/choice of each component based on its defined properties. The toolbox is built and can only be used with python. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:2:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"How do I use it? It’s recommended to use the Jupyter extension within Visual Studio Code to define and analyze a specific gearbox configuration, as well as perform all the required analyses. The reason is that with Jupyter, the user can write the code in a series of blocks and run each block separately. In this specific context, this allows the user to perform step-by-step definitions and calculations in order to perform all the required analyses sequentially. Having Pylance as yet another Visual Studio Code extension helps the user with recommendations while coding the problem at hand. For example, when defining components by their corresponding characteristics, Pylance will give recommendations on the characteristics that need to be defined based on the Class to which the specific component belongs. More on that in the next sections. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:3:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Installation To install the toolbox: Install Python. Open the Command Prompt (Windows) or Terminal (MacOS) (addressed as cmd in the rest of the tutorial). If you don’t use environments in your python devlepment, proceed to step 4. If you use environments in your python development, either activate a desired environment or create a new one and activate it. Type pip install pygritbx then hit the enter key. Note that the toolbox relies on Numpy, Matplotlib and Scipy. Therefore, make sure they are installed before proceeding to use the toolbox. In theory, these libraries will be installed automatically with the toolbox but it’s better to make sure they’re there before starting any project. Make sure you have the latest version of the toolbox by first typing python into your cmd then hit enter. Once python is activated, type import pygritbx as pgt then hit enter. After that type print(pgt.__version__) and hit enter. This will print the version number of the toolbox that you have currently installed. Make sure it’s the same version number as the one shown following this link. To install Visual Studio Code, choose the right one based on your computer’s operating system: VS Code ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:3:1","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"First Lines of Code as a Check Create an empty folder and open it with VS Code. Create a new file and, for simplicity, let’s call it “project.ipynb”. Open the file and add a new code block by pressing on \"+ Code\". Inside the block, type the following: import numpy as np import pygritbx as pgt print(pgt.__version__) # output example: # 1.1.2 Making sure the block is selected you can press Shift+Enter to execute the code and show the output which in this case is the version number of the toolbox you have installed. In this block, we also import Numpy which we will use in the next block. Add another block to define the reference frame that we will use in the project: i = np.array([1, 0, 0]) j = np.array([0, 1, 0]) k = np.array([0, 0, 1]) RF = np.array([i, j, k]) Make sure to press Shift+Enter to run the code in the block. The unit vectors ‘i’, ‘j’, and ‘k’, correspond to the ‘x’, ‘y’, and ‘z’ axes, respectively. You can think of ‘RF’ as the reference frame holding the three unit vectors together. To proceed with our project, we must first understand the characteristics of its underlying components. Therefore, in the next section, we will check how to define the necessary objects one by one. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:3:2","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Gearbox Configuration The gearbox we will attempt to analyze in this tutorial can be seen in Figure 1. This is taken from the project of the academic year 2024/2025. The gearbox is composed of: Input shaft A1 transmitting power from the input motor via key L1 to gear R1. The shaft is supported by bearings A and B. Gear mesh transmitting power from gear R1 to gear R2. Denote it by M1. Intermediate shaft transmitting power from gear R2 to gear R3 by spinning around the spindle P. Gear mesh transmitting power from gear R3 to gear R4. Denote it by M2. Output shaft A2 transmitting power from gear R4 via key L2 to the output user via the key L3. The shaft is supported by bearings C and D. Figure 1 - Gearbox Assembly A simplified scheme can be seen in Figure 2. In this scheme, we can see the orientation of the: input angluar velocity input torque output load (forces and torque) gear tooth inclination with respect to the given reference frame. Figure 2 - Gearbox Scheme ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Input Motor Starting with the input motor, the given characteristics are shown in Table 1. Table 1 - Input Motor Operating Point Power [W] Speed [rpm] 6000 2750 To define the input motor in our code: # Input Motor input_motor = pgt.Motor(name=\"Input Motor\", power=6e3, n=2750, axis=+k) This defines the input motor object input_motor with the label “Input Motor”, power set to “6000 [W]”, rotational speed set to “2750 [rpm]”, and rotating around the “z-axis” in the positive direction. Note that a Motor object is represented by the power equation which is the product of torque and rotational speed: $$ Power = Torque * Speed $$ Therefore when defining a Motor object, it’s necessary to provide at least 2 out of these 3 values and the toolbox will calculate the third. In this particular case, we provide the object definition with power and speed; hence, the toolbox will automatically calculate the torque vector. This can be checked by executing the following: print(input_motor.ETs[0].torque) # output # [ 0. 0. 20.83482891] By first converting the rotational speed unit to [rad/s], the toolbox then divides the power by the converted speed value to get the torque as a vector acting in the same direction as the rotational speed. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:1","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Gears Next, we are the given the gears’ characteristics which can be seen in Table 2. Table 2 - Gears Characteristics Property R1 R2 R3 R4 Normal Module (mn) [mm] 2.5 2.5 2.5 2.5 Number of teeth (z) [-] 18 73 19 51 Helix Angle (ψ) [°] 20 20 20 20 Normal Pressure Angle (Φn) [°] 20 20 20 20 Transmission Accuracy Level (Qv) [-] 7 7 7 7 Tooth Face Width [mm] 30 30 30 30 Ultimate Strength (σu) [MPa] 1060 1950 1950 1060 Yield Strength (σy) [MPa] 950 1400 1400 950 Surface Hardness [HB] 335 560 560 335 Bending Fatigue Strength (σFP) [MPa] 320 450 450 320 Contact Fatigue Strength (σHP) [MPa] 860 1360 1360 860 Note that these properties can be classified into: Gear Material Properties Gear Physical Properties In our definition, we will separate these 2 sets of properties. We can also see that gears R1 and R4 share the same material properties, while gear R2 material properties match that of gear R3. # Gear Material Properties Definition R1R4_material = pgt.Material(name='Steel', sigma_u=1060, sigma_y=950, HB=335) R2R3_material = pgt.Material(name='Steel', sigma_u=1950, sigma_y=1400, HB=560) At this point, the object R1R4_material holds material properties for gears R1 and R4, while R2R3_material holds material properties for gears R2 and R3. These material objects will be used during the defintion of the gear objects as follows. NOTE: DO NOT RUN THE FOLLOWING CODE BLOCK JUST YET. THERE’S ONE MORE PARAMETER THAT WILL BE DISCUSSED SHORTLY. # Gears # R1 R1 = pgt.Gear(name=\"R1\", axis=k, m_n=2.5, z=18, psi=20, phi_n=20, Q_v=7, FW=30, material=R1R4_material) # R2 R2 = pgt.Gear(name=\"R2\", axis=k, m_n=2.5, z=73, psi=-20, phi_n=20, Q_v=7, FW=30, material=R2R3_material) # R3 R3 = pgt.Gear(name=\"R3\", axis=k, m_n=2.5, z=19, psi=20, phi_n=20, Q_v=7, FW=30, material=R2R3_material) # R4 R4 = pgt.Gear(name=\"R4\", axis=k, m_n=2.5, z=51, psi=-20, phi_n=20, Q_v=7, FW=30, material=R1R4_material) At this point, each gear object has a label, axis of rotation, normal module, number of teeth, helix angle, normal pressure angle, transmission accuracy level, tooth face width, and material properties defined. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:2","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Bearings Defining bearing objects isn’t as straightforward as the previous definitions unfortunately. This is because bearings come in different types, each type with its own set of properties. However, some of these properties are shared across different types of bearings (e.g. bearing width, internal diameter, reference speed, etc.). PyGRITbx supports only SKF bearings, and luckily, the SKF Rolling Bearings catalogue is freely available for anyone to download. Using the catalogue, we will define bearing objects by their properties. Some additional properties related to the specific configuration of the gearbox will also be defined and explained in the following. Bearings A and B are given as SKF 30203 (Explorer) bearings. By searching through the SKF Catalogue, we find their characteristics as shown in Figure 3 and Figure 4, in the row enclosed in the blue rectangle. Figure 3 - SKF 30203 (Explorer) Specs 1 Figure 4 - SKF 30203 (Explorer) Specs 2 Similarly, we can find bearings C and D which are designated by SKF 30208 (Explorer). Their characteristics are shown in Figure 5 and Figure 6 in the row enclosed in the blue rectangle. Figure 5 - SKF 30208 (Explorer) Specs 1 Figure 6 - SKF 30208 (Explorer) Specs 2 Based on the information from the catalogue, we can then define the bearing objects in python as follows. NOTE: DO NOT RUN THE FOLLOWING CODE BLOCK JUST YET. THERE’S ONE MORE PARAMETER THAT WILL BE DISCUSSED SHORTLY. # Supports # A (roller 30203) A = pgt.Support(name=\"A\", type=\"Roller\", bearingType=\"Tapered\", catalogueName=\"30203\", catalogueType=\"Explorer\", d=17, D=40, B=13.25, C=23.4e3, C0=18.6e3, Pu=1.83e3, nr=15e3, a=9, e=0.35, X=0, Y=1.7, Y0=0.9, Y1=0, Y2=0, A=0, kr=0, shoulder=-1, arr=\"B2B\", axis=k) # B (roller 30203) B = pgt.Support(name=\"B\", type=\"Pin\", bearingType=\"Tapered\", catalogueName=\"30203\", catalogueType=\"Explorer\", d=17, D=40, B=13.25, C=23.4e3, C0=18.6e3, Pu=1.83e3, nr=15e3, a=9, e=0.35, X=0, Y=1.7,Y0=0.9, Y1=0, Y2=0, A=0, kr=0, shoulder=1, arr=\"B2B\", axis=k) # C (roller 30208) C = pgt.Support(name=\"C\", type=\"Roller\", bearingType=\"Tapered\", catalogueName=\"30208\", catalogueType=\"Explorer\", d=40, D=80, B=19.75, C=75.8e3, C0=68e3, Pu=7.65e3, nr=7e3, a=16, e=0.37, X=0, Y=1.6, Y0=0.9, Y1=0, Y2=0, A=0, kr=0, shoulder=-1, arr=\"B2B\", axis=k) # D (roller 30208) D = pgt.Support(name=\"D\", type=\"Pin\", bearingType=\"Tapered\", catalogueName=\"30208\", catalogueType=\"Explorer\", d=40, D=80, B=19.75, C=75.8e3, C0=68e3, Pu=7.65e3, nr=7e3, a=16, e=0.37, X=0, Y=1.6, Y0=0.9, Y1=0, Y2=0, A=0, kr=0, shoulder=1, arr=\"B2B\", axis=k) # F F = pgt.Support(axis=k) # Generic bearing for the spindle. Characteristics are irrelevant. It’s worth spending a couple of words regarding the properties defined which are NOT present in the SKF Catalogue: name: this is simply a label that you are free to choose or simply leave empty. type: this can be either Roller or Pin, depending on the support type. Each shaft is supported by at least 2 supports and it’s necessary to define one of the supports as Roller and the other as Pin. Sometimes this is given in the scheme in Figure 2. In this specific example and by looking at shaft A1, we can see that both bearings, A and B, are Pins; therefore, how do we choose which to define as Roller and which as Pin? The answer: it doesn’t matter. This is because the SKF catalogue provides a way to calculate the axial forces as shown in Figure 7. But don’t worry, PyGRITbx will do this calculation for you. bearingType: depending on the bearing type, this could be Ball, Tapered, or Contact Ball bearing. catalogueType: based on the SKF Catalogue, the bearing could be a Standard or Explorer bearing. shoulder: this parameter is set to 1 if the axial shoulder is located in the positive sense of the shaft’s axis with respect to the bearing and -1 otherwise. Example: if the shaft’s axis is pointing to the right and the shoulder is to the right of the bearing, the parameter must be set to 1. If the shaft’s axis is pointing to ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:3","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Components’ Locations In this section, you’ll learn how to easily define your components’ locations. Locations of components belonging to the same shaft is an essential part of calculating the reaction forces produced by the bearings. PyGRITbx gives you the possibility to define the: Absolute location of the component relative to a chosen reference frame defined as a vector. Relative location of the comopnent relative to the rotation axis of the shaft it belongs to defined as a scalar. Depending on the given, one way or the other might be convenient for you. In our example, relative distances between components are given as shown in Figure 8. Let’s break it down one shaft at a time. Figure 8 - Relative Axial Distances - Shaft A1 For this shaft, we have to locate the following components: Bearing A at its pressure center Bearing B at its pressure center Gear R1 at its midplane Bearing A will be located at the origin as shown in Figure 9. Our mission is to calculate $\\mathbf{a_1}$ and $\\mathbf{b_1}$ to locate bearing B and gear R1. Figure 9 - Shaft A1 Scheme However, given that the bearing is a tapered roller bearing, we’re actually saying that the bearing’s pressure center, which has an offset from the bearing’s center point, is located at the origin (point in red circle in Figure 10). Figure 10 - Tapered Roller Bearing Center To calculate $\\mathbf{a_1}$ and $\\mathbf{b_1}$, we will refer to shaft A1’s zoomed-in scheme in Figure 11. Figure 11 - Shaft A1 Relative Axial Distances The distance between the faces of the bearings A and B is reported as 28.75 [mm]. The pressure center of bearing A is offset to the left and that of bearing B is offset to the right. Therefore, to calculate $\\mathbf{a_1}$, we simply have to follow the equation: $$ a_1 = a_A + 28.75 + a_B = 9 + 28.75 + 9 = 46.75 [mm] $$ To calculate $\\mathbf{b_1}$, we have that the distance from the right side of bearing B to the left side of gear R1 is 24.25 [mm]. To that, we have to add the distance from the pressure center of bearing B to the rightmost side of bearing B, and half of the width of gear R1 so as to locate it at its middle plane. To calculate the distance between bearing B’s pressure center and its rightmost side, we simply subtract the offset distance of the pressure center from the width of the bearing. Therefore, to calculate $\\mathbf{b_1}$, we follow the equation: $$ b_1 = (B_B - a_B) + 24.25 + (FW_{R1}/2) = (13.25 - 9) + 24.25 + (30/2) = 43.5 [mm] $$ At this point, we can define the location of all the components on shaft A1 as shown in the following code block: # Shaft A1 Components' Locations a1 = 46.75 # [mm] b1 = 43.5 # [mm] zA = 0 # [mm] zB = a1 zR1 = a1 + b1 # [mm] Note that since these locations are defined as scalars, they are NOT the absolute locations of the components. They actually represent the relative locations of the components with respect to shaft A1’s rotational axis! The aboslute locations of the components will be calculated automatically by the toolbox once we define shafts and meshes. Now let’s switch our focus to the spindle. - Spindle P Locating the components on this spindle is unnecessary for the purpose of the project. In fact, it’s impossible to accurately locate the components on the spindle relative to each other due to missing information. However, we can still make some assumptions so as to portray the locations of the subsequent components in the global reference frame. Components that need to be located are: Gear R2 at its midplane Gear R3 at its midplane For simplicity, we will assume that the location of gear R2 is at the origin of the spindle and that the location of gear R3 is represented by a scalar which is bigger than the sum of half the widths of both gears. That is: $$ z_{R3} \u003e (FW_{R2}/2) + (FW_{R3}/2) = (30/2) + (30/2) = 30 [mm] $$ We will assume it as 55 [mm]. Therefore, the locations are defined as follows: # Spindle P Components' Locations zR2 = 0 # [mm] zR3 = 55 # [mm] Now let’s switch to the final set ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:4","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Output / User / Load One more step remains before we start defining how all these components interact with each other via shafts and meshes. This is a relatively simple step where we define a generic compnent that represents the output load produced by the user. If you paid close attention to the locations defined in the previous section, you’ll realize there’s a $\\mathbf{z_{Out}}$ defined which I haven’t mentioned before. This is indeed the relative location of the load with respect to shaft A2. From Figure 2, we know how this output load is oriented but we don’t know its magnitude. It’s given as a set of equations (Figure 15) with respect to other loads that need to be calculated first. Figure 15 - Output Load Equations Therefore, for the time being, we will only define the component and then update its forces after we perform some initial calculations: # Output Component output = pgt.Component(name=\"Output\", axis=k, loc=zOut) ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:5","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Shafts \u0026 Meshes In this section, we will define our last components. Shafts and Meshes are special components in PyGRITbx because they allow us to define how all the other regular components interact with each other. Moreover, the toolbox calculates the absolute locations of all components (if not already defined) using these special components. So without waiting further, let’s start defining these special components. - Shaft A1 I think by now, you got a hint of how the toolbox works: if you want to define a certain component, let’s say a shaft, then you’d need to type something like pgt.Shaft(...) and identify its characteristics in the parantheses. You wouldn’t be wrong to think that; hence, the definition of A1: # Shaft A1 Definition A1 = pgt.Shaft(name=\"A1\", inputs=[input_motor], outputs=[R1], sups=np.array([A, B]), axis=k, loc=[0, 0, 0], material=shaftMaterial) Some words regarding the shaft’s defined parameters: name: this is simply a label that you are free to choose or simply leave empty. inputs: an array of defined objects that represent the input load(s) from the shaft’s perspective. outputs: an array of defined objects that represent the output load(s) from the shaft’s perspective. sups: an array of defined supports that are supposed to hold the shaft. axis: the unit vector corresponding to the axis around which the shaft rotates. loc: a vector that represents the absolute location of the shaft with respect to the global reference frame. material: a defined material object that holds the material characteristics of the shaft. When we execute the code in the previous block, PyGRITbx calculates the absolute locations of all the components involed in the definiion: input(s), output(s), and supports. Now we can move to our first mesh definition. - Mesh M1 To define a mesh, we need to understand which is the driving gear and which is the driven gear. For the mesh between gears R1 and R2, the former is the driving and the latter is the driven. Moreover, we need to understand a property called radiality. Imagine putting your finger on the center of the driving gear, R1, then try to move your finger along one axis or two axes to reach the center of the driven gear, R2, in the shortest way possible. Which axis or axes did you have to follow? The answer to this question is the radiality array. In our case, to go from gear R1 to gear R2, along the shortest path, you need to move along the y-axis in the negative sense; therefore, the radiality is set to -j. One last thing to note is that this is an external gear mesh and not an internal gear mesh. Hence, the definition of the mesh can be seen in the following block: # Mesh M1 Definition M1 = pgt.GearMesh(name=\"M1\", drivingGear=R1, drivenGear=R2, radiality=[-j], type=\"External\") Given that the definition of shaft A1 calculated the absolute location of gear R1, with the defintion of mesh M1 we actually just calculated the absolute location of gear R2. This is because PyGRITbx already calculated all the necessary properties of the gears (e.g. pitch radius), and using the radiality property, it knows in which direction to go to locate the center of gear R2 from gear R1. Now we can define the spindle as another shaft. - Spindle P Similar to shaft A1, spindle P would have a name, inputs, outputs, and sups properties. For the location? Well, given that we know gear R2’s relative location with respect to the spindle and that gear R2’s absolute location has just been calculated by the definition of mesh M1, the toolbox will calculate the absolute location of the spindle automatically. As a result, we can define the spindle as follows: # Spindle P Definition spindleP = pgt.Shaft(name=\"P\", inputs=[R2], outputs=[R3], sups=np.array([F, F]), axis=k) Note that from the spindle’s perspective, it receives an input load from gear R2 (input) and transfers that through gear R3 (output). The supports are there but we’re not required to calculate any reaction forces on them so it doesn’t really mat","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:4:6","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"May the Forces Resolve For You In the previous section, we learnt how to define the components a gearbox is composed of (gears, bearings, shafts, users). We also learnt how to define the interactions between these components using shafts and meshes. Now is the time to harvest some fruits in return: solving for the exchanged forces between components and the reactions produced by the bearings. It’s important to note that approaching such problems is a sequential process. In other words, if you’re solving this project by hand, you would start by the torque equilibrium condition on shaft A1 around the z-axis to get the torque on gear R1 (in this case, it’s the same as the torque produced by the input motor but in the opposite sense). Through the torque, you would then calculate the tangential force acting on gear R1 by dividing this calculated torque by the pitch radius of the gear. After that, you can use the pressure and helix angles to calculate the resultant force acting on gear R1 which you can then resolve into the axial and radial directions. From there, you can apply equilibrium equations and equations given by the SKF catalogue to calculate all the reaction forces produced by the bearings. Sounds hideous? Yes. How many times did I have to do it in my life? Countless. Hence, the toolbox! ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Shaft A1 Using PyGRITbx, you only need to call the function .solve() on shaft A1 and it will do all of this for you! Through the process, the toolbox will prompt you with some questions. Let’s see an example by solving for shaft A1: # Solving for shaft A1 A1.solve() Once you run the previous block, you’ll get the output shown in Figure 16. PyGRITbx first checks the torque equilibrium on the shaft around its rotational axis and, if that’s not satisfied, it attempts to resolve it by setting the output torque equal to the input torque but in the opposite sense. If that is done successfully, you’ll get the prompt in Figure 17 telling you that a torque has been detected on the output (in this case gear R1); therefore, would you like to solve for the torque equilibrium of that component around its rotational axis? In other words, would you like to calculate the forces on gear R1? These are the tangential, radial, and axial forces since R1 is a gear. Therefore, our answer should be y. Figure 16 - Solving for A1 --\u003e Output 1 Figure 17 - Solving for A1 --\u003e Detected Toruqe Prompt Once you hit enter after inserting y, you’ll get additional messages informing you that the toolbox is attempting to solve the forces on gear R1 (Figure 18). Once an equilibrium is reached on gear R1, the toolbox switches its focus back to shaft A1 and checks its force equilibrium. If the force equilibrium isn’t satisfied then you’ll get the prompt shown in Figure 19 asking you to solve the reaction forces on the bearings that support the shaft. If you’re interested in the reaction forces, then you should enter y and hit enter. Otherwise, enter n and hit enter. In this case, we are interested so we must enter y and hit enter. Figure 18 - Solving for A1 --\u003e Output 2 Figure 19 - Solving for A1 --\u003e Reaction Forces Prompt Eventually, the toolbox will calculate the reaction forces produced by the bearings, and it will output the relevant messages to confirm that. Furthermore, in case of tapered roller bearings, it will inform you of the specific case it found to solve the axial forces based on the SKF Catalogue. Figure 20 - Solving for A1 --\u003e Final Prompt To see the reaction forces, run the following blocks: # Reaction Forces on Bearing A print(A.F_tot.force) # output # [-809.65663399 475.8122391 -865.57152262] # Reaction Forces on Bearing B print(B.F_tot.force) # output # [1679.80485557 -812.84590846 548.86347056] ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:1","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Gear R2 For gear R2, we would like to transmit the forces from gear R1 to it. Again, we simply use the .solve() function but this time on the gear object R2: # Solving for Gear R2 R2.solve() Running this block will produce the messages shown in Figure 21. The toolbox checks the torque equilibrium of gear R2 around its rotational axis. If that’s not satisfied, it checks for the solvability. Particularly, the toolbox goes and looks at the meshes in which gear R2 is included. If there are torques/forces already resolved in those meshes, then the toolbox will pass them onto the gear. Given that we already solved for gear R1 when we answered yes on the first prompt while solving for shaft A1, the toolbox resolved the torque and forces in mesh M1 in hindsight. Now that we call .solve() on R2, the toolbox finds those torque and forces and applies them onto gear R2. Figure 21 - Solving for R2 ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:2","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Spindle P For spindle P, we only care about transmitting the load from gear R2 to gear R3. So let’s run the following code block: # Solving for Spindle P spindleP.solve() When prompted with solving the equilibrium for gear R3, we should answer y. However, when prompted with calculating the reaction forces on the spindle, we should answer n. The output messages are shown in Figure 22. Figure 22 - Solving for Spindle P ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:3","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Gear R4 Now that we solved for gear R3 via the spindle P, we can directly jump to solve for gear R4 just like we did for gear R2 after solving shaft A1. # Solving for Gear R4 R4.solve() ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:4","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Output Now that we solved for gear R4, we actually have the torque applied on shaft A2. Recalling the equations to calculate the forces exerted by output user from Figure 15, we can actually now set the forces of the output user via the following block: # Calculating the Forces on Output User Fout_r = np.abs(np.sum(R4.ETs[0].torque)) / 0.1 * j Fout_a = 0.25 * np.abs(np.sum(Fout_r)) * (-k) Fout = pgt.Force(force=Fout_a+Fout_r, loc=output.abs_loc) A2.outputs[0].updateEFs([Fout]) First, we calculate the radial force. This is equal to the torque on R4 (equal to torque on A2) in the positive y-axis direction; hence, the multiplication with the unit vector j. Second, we calculate the axial force. This is 0.25 multplied by the radial force but directed in the negatice z-axis direction; hence, the multiplication with the unit vector -k. Third, we define a Force via the toolbox whose vector is the sum of the radial and axial forces and location coincides with the absolute location of the output component we defined earlier. Finally, we update the forces on the first, and only, output of the shaft A2. ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:5","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Shaft A2 At this point, we can resolve the forces on shaft A2 and answer y on the prompt regarding the calculation of the reaction forces. We will not get the prompt for solving the equilibrium on the output because in this case the output is NOT a gear but a generic component. # Solving for Shaft A2 A2.solve() Figure 23 - Solving for Shaft A2 To check the reaction forces on the bearings C and D, we can run the following blocks: # Reaction Forces on Bearing C print(C.F_tot.force) # output # [-4712.18425533 -217.84651183 -1474.13035668] # Reaction Forces on Bearing D print(D.F_tot.force) # output # [ 1368.98319344 -3345.14448819 3257.97407164] ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:5:6","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"Final Words If you made it to this point, then you survived my attempt to portray my experience in explaining this exercise that I had taught for several years. Congratulations, mastering this part will help you save time solving this project. In short, we analysed the configuration of a given gearbox composed of an input, intermediate, and output shaft. Power is transmitted from the input motor to the output user thanks to the gears mounted on the shafts. All the loads exchanged during the power transfer are supported by the SKF bearings that hold the shafts in place. Through this analysis, we were able to define objects representing these components. We also configured the interaction between said components. This allowed us to model the power flow by calculating the loads exhanged between them as well as the reaction forces produced by the bearings. With this, we conclude the first part of the gearbox components design verification process via a simple toolbox: PyGRITbx. For the next part, we will perform the static and fatigue verification on shaft A2. So stay tuned =) ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:6:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":["Mechanical Engineering","Programming Tutorial"],"content":"References Richard G. Budynas and J. Keith Nisbett, Shigley’s Mechanical Engineering Design, McGraw-Hill, 2006. SKF Group, SKF Rolling Bearings Catalogue, SKF. SKF Rolling Bearings ","date":"2026-01-31","objectID":"/posts/pygrtibx_tutorial1/:7:0","tags":["Machine Design"],"title":"PyGRITbx - Tutorial Series Part 1: May The Forces Resolve for You","uri":"/posts/pygrtibx_tutorial1/"},{"categories":[],"content":"Welcome To My Website","date":"2026-01-21","objectID":"/posts/intro/","tags":[],"title":"Intro","uri":"/posts/intro/"},{"categories":[],"content":"Welcome To My Website Hello and welcome to my website. I will attempt to share my thoughts with the interested reader using blog posts. Topics will vary in discipline but mainly I would like to portray my perspective on the following: Mechanical Engineering Programming Tutorial for Engineers Books and Recommendations Music Religion Who knows what(?) Please note that I will try my best to backup my thoughts and ideas with references that would lead the reader to the source. However, everything I share is based on my humble knowledge and experience on the subject matter and mistakes are to be expected. This is why I urge the kind reader to reach out in case correction is required, to discuss a topic further, or simply to connect! I hope you enjoy it :D ","date":"2026-01-21","objectID":"/posts/intro/:0:0","tags":[],"title":"Intro","uri":"/posts/intro/"},{"categories":[],"content":"Portfolio","date":"2026-01-10","objectID":"/portfolio/","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Portfolio In the following, you can find a list of projects I worked on either during my academic or professional career. For academic projects, I’ll link each to its GitHub repository. However, projects developed during my professional career are classified; therefore, I hope a comprehensive description would suffice. Professional Career Projects ","date":"2026-01-10","objectID":"/portfolio/:0:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"E-Axle Development \u0026 Testing (Dana Graziano | Atesteo GmbH \u0026 Co. KG) ","date":"2026-01-10","objectID":"/portfolio/:1:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description As a Mechatronics Testing Engineer @ Dana Graziano, my role in this project was to assist in the development and testing of an e-axle to a well-known OEM around the globe. The e-axle in subject consists of a housing encompassing 2 independent electric motors sharing one inverter, each linked to the rear wheel of the corresponding side of the car via a 2-stage speed-reducer. ","date":"2026-01-10","objectID":"/portfolio/:1:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Duration I worked on this project in the aforementioned role during the prototyping and design validation phases. I’m still following this project in my current role as Engineering Project Manager @ Atesteo during the production process validation phase. ","date":"2026-01-10","objectID":"/portfolio/:1:2","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tasks My main tasks are/were the following: Disucss and modify test specifications with Lead Testing Engineer and System Validation Engineer based on stakeholder requirements. Support CAD Engineers with the development of required fixtures for said tests (mechanical interface). Support electricians with the development of required cables to power the e-axle and communicate with it (electrical and communication interface). Supervise outsourced tests. Supervise and/or execute internal tests. Data post-processing, reporting, and presenting for all tests. Corrective action analysis, development, and implementation in case of failures. Software debugging with Software Development Team. ","date":"2026-01-10","objectID":"/portfolio/:1:3","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tests The tests developed and executed on the e-axle are organized in 2 different categories: Mechanical-based: where only mechanical components are concerned. System-based: where the whole e-axle as a system is considered. The list of tests is comprised of the following: Oil Cump Characterization Lubrication Evaluation Gear Contact Pattern Backlash and Torsional Stiffness Measurement Mechanical and System Efficiency Mechanical and System Durability Mechanical Torque-to-Failure (TTF) Scuffing Test System Performance System Environmental Tests End-of-line (EOL) ","date":"2026-01-10","objectID":"/portfolio/:1:4","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tools Used For handling the test development, execution, and reporting, the following tools were used: CANape as a signal measurement and logging tool as well as diagnostic tool for XCP parameter calibration. LabVIEW as an automation system development tool to control internal benches. VBA for Excel for automated data post-processing and product certification. MATLAB for virtual analysis on bench setup performance and data post-processing. Python for creating data post-processing tools and generating them as executables (.exe) for distribution across team members. JIRA for tracking different issues to implement corrective actions across the global team. Siemens Polarion for tracking stakeholder requirements and linking them to the corresponding test cases and specifications. Creo CAD for the development of mechanical interfaces and CAD handling. ","date":"2026-01-10","objectID":"/portfolio/:1:5","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"CFD Analysis for Aerodynamics Performance (AEHRA) ","date":"2026-01-10","objectID":"/portfolio/:2:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description As a CFD Analyst @ Aehra, my role in this project was to evaluate the aerodynamics performance of 2 models by performing iterative CFD simulations and analyses. Working under the supervision of one of the top designers worldwide, I learnt a lot from this experience, especially when it comes to car shape design. The main challenge was to come up with an innovative design that would define the DNA of electric vehicles, taking advantage of luxurious ergonomics and maintaining high aerodynamics performance. ","date":"2026-01-10","objectID":"/portfolio/:2:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Duration I worked on this project for 1 year, during the prefeasibility study of the 2 models. ","date":"2026-01-10","objectID":"/portfolio/:2:2","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tasks Working with 3 designers, I had the following responsibilities in this project: CAD Cleaning CFD Simulation \u0026 Analysis CAD Modification Reporting ","date":"2026-01-10","objectID":"/portfolio/:2:3","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tools Used To achieve the tasks, the following tools were used: Autodesk Alias for CAD cleaning and modification. Simcenter Star-CCM+ for CFD simulation and analysis. ","date":"2026-01-10","objectID":"/portfolio/:2:4","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Masters Thesis (General Motors) Although a masters thesis might seem like an academic project, I decided to put it under this section specifically because it was a paid internship concerning a case study for GM. ","date":"2026-01-10","objectID":"/portfolio/:3:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description Titled “Global Engine Durability On Cylinder Head and Block Related to The Physical Test Duration”, the thesis proposes an elaborate methodology to perform finite-element fatigue simulations on a combustion engine’s head and block, highlighting the contribution of specific key factors for better accuracy. To verify its claim of better acccuracy, the methodology was tested on an already existing engine by comparing the results with previous simulation methodologies. Moreover, the new methodology relies on a different fatigue algorithm that outputs the lifetime in hours, as opposed to the previous methodology, which only provided a safety factor. This latter point allowed for a direct comparison between simulation results and the results coming from the real physical test, which indeed showed that the new methodology is significantly accurate. ","date":"2026-01-10","objectID":"/portfolio/:3:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Duration I worked on this project for 6 months. ","date":"2026-01-10","objectID":"/portfolio/:3:2","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tasks As a CAE Intern, the main tasks constituted of the following: Understanding the topic of the thesis from a theoretical and technical perspective. Research available literature for different proposals. Learn how to operate used software for building model setups and running simulations. Propose and discuss different alternatives with local (Italy) and global (North America) teams. Continuous reporting on progress. Writing the thesis and presenting it. ","date":"2026-01-10","objectID":"/portfolio/:3:3","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Tools Used To achieve this milestone, the following tools were used: Altair HyperMesh as a finite element pre-processor with Abaqus as the non-linear thermo-structural finite element solver. FE-Safe for fatigue analysis on finite element models. MATLAB for comparing different fatigue algorithms on simplified models. Python for defining a new durability cycle on FE-Safe based on the engine specs. General Motors internal tools for precise material card modeling. Academic Career Projects ","date":"2026-01-10","objectID":"/portfolio/:3:4","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"PyGRITbx ","date":"2026-01-10","objectID":"/portfolio/:4:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description “Python-based Gearbox Realiability and Integrity Toolbox” is a comprehensive python toolbox based on a project that 3rd year mechanical engineering students seeking their bachelor degree at Politecnico di Torino following the course “Fundamentals of Machine Design” must report. ","date":"2026-01-10","objectID":"/portfolio/:4:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"User’s Tasks To benefit from the toolbox, the user should perform the following: Define a reference frame. Define locations of gears and bearings on shafts with respect to the shafts’ rotating axes. Define object representing input motor. Define material cards for shaft(s) and gear(s). Define objects representing gears (spur, helical, or bevel). Define objects representing bearings (only SKF bearings supported). Define object representing output load. Define gearbox configuration via shafts and gear meshes. Define shaft(s) profile(s) with fillets. Define sections of interest. Define oil characteristics. ","date":"2026-01-10","objectID":"/portfolio/:4:2","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Toolbox Capabilities After having defined objects representing the gearbox components and their interaction, the user would proceed with exploiting the toolbox’s solver to perform the following: Use .solve() function on shafts to calculate reaction forces, and on gears to calculate forces on teeth. Use .performStaticVerification() function on shafts to calculate internal loads and stresses across the shaft’s profile; as well as, the static safety factor on the sections of interest. Use .performFatigueVerification() function on shafts to plot Haigh Diagram and calculate fatigue safety factor on sections of interest. Use .analyseGearToothBending() function on gears to calculate maximum gear tooth bending stress for fatigue and the gear tooth bending safety factor. Use analyseGearToothPitting() function on gears to calculate maximum gear contact stress and the wear safety factor. Use performLifeAnalysis() function on bearings to: Check minimum load condition. Calculate bearing’s equivalent static load. Calculate static safety factor. Calculate reliability factor. Calculate equivalent dynamic load. Calculate contamination factor based on given conditions. Calculate bearing life. ","date":"2026-01-10","objectID":"/portfolio/:4:3","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Future Plans \u0026 Contribution Starting from excel, switching to MATLAB, and finishing with Python, I worked on this project for several years to have it polished in this latest version. However, the project has yet some potential in it that should be exploited and I would welcome any contributors with ideas or technical skills. Specifically, I would like to implement the following in the near futur: Hollow shafts profile definition with internal and external radii. Discretize the shaft profile into a mesh of computational nodes holding values of internal loads and stresses to plot a contour representing them. Bearing positioning optimization analysis. ","date":"2026-01-10","objectID":"/portfolio/:4:4","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Use of a Fractal Model for Combustion Engine Prediction in a SI Engine Running on HCNG: Speed and Load Effect ","date":"2026-01-10","objectID":"/portfolio/:5:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description This was my bachelor’s degree thesis project under the supervision of Professor Mirko Baratta. With the help of an already-developed fractal combustion model, I worked on GT-Suite to perform combustion simulations and verify the results with those coming from lab experiments. The aim was to verify the model’s behaviour as engine speed and load changed. ","date":"2026-01-10","objectID":"/portfolio/:5:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Dual-Clutch Transmission Output Shaft Design ","date":"2026-01-10","objectID":"/portfolio/:6:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description Developed while following the course “Powertrain Components Design”, we were separated into different teams, each responsible for the design of certain components to develop a DCT given the engine’s characteristics. My team and I were responsible for the output shafts design. Instead of opting for conventional methods, we defined a new optimization methodology aiming at the reduction of material and thus the mass of the shafts by solving a 6th order polynomial at each increment along the shafts’ axes for different gear engagements. Feel free to check the MATLAB live script: DCT_OutputShaft ","date":"2026-01-10","objectID":"/portfolio/:6:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"WheelArch ","date":"2026-01-10","objectID":"/portfolio/:7:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description Developed while following the course “Car Body Design”, the task was to simply design the wheel arches for any car available alread on the market, for which the specs can be easily found online. Being the first step in the ergonomics study of a vehicle, wheel arch design is essential for the definition of the firewall which separates the passenger and the engine compartments. Once the firewall is placed, the pedals can be positioned and based on anthropomorphic data for different markets, the driver seat can be placed after which all the passengers can be positioned. Although it might seem like a boring task, it would be if performed only for one car. However, I tried to make this project interesting by learning the GUI tool in MATLAB to develop an application/toolbox that can be downloaded by anyone having a MATLAB license. This then allowed me to verify its functionality by testing it on more than one car. The tool can also perform a 2-degrees of freedom quarter car model analysis based on a chosen road grade and vehicle speed. An optimization of the damping coefficient for the damper can be performed. GitHub link: WheelArch Mathworks link: WheelArch ","date":"2026-01-10","objectID":"/portfolio/:7:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Vehicle Longitudinal Dynamics, Acceleration Performance, and Fuel Consumption ","date":"2026-01-10","objectID":"/portfolio/:8:0","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Description Marking as my first serious project programmed in MATLAB, this project is the first out of 5 that we worked on while following the course “Motor Vehicle Design”. Given a car’s characteristics and an engine map containing specific fuel consumption and mean effective pressure as a function of engine rotational speed, we were asked to: Calculate and plot the power needed for motion according to the car’s specifications at different road inclinations. Calculate and plot power available by the internal combustion engine. Perform gradeability and initial choice of the transmission ratios. Compute the maximum power that can be transferred by the tires to the ground. Perform acceleration performance of the car when equipped with the given engine and after freezing transmission ratios. Compute fuel consumptioni for the NEDC driving cycle. Note: I would like to rewrite the code in Python using POOP so as to generalize the code as much as possible. GitHub link: MVD_Project-1 ","date":"2026-01-10","objectID":"/portfolio/:8:1","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":[],"content":"Further Projects The 4 remaining projects developed during this course can be found via the following links: Linear and Non-linear Behaviour of Tires Kinematic Behaviour of a Vehicle Front Suspension Braking Analysis Vehicle Lateral Dynamics ","date":"2026-01-10","objectID":"/portfolio/:8:2","tags":[],"title":"Portfolio","uri":"/portfolio/"},{"categories":null,"content":"About Me","date":"2012-07-23","objectID":"/about/","tags":null,"title":"About Me","uri":"/about/"},{"categories":null,"content":"Hello there! My name is Ragheed Huneineh, I’m currently based in Aachen, Germany, and I’ve been working on E-Axle Development \u0026 Testing with different OEMs across the globe for the last 4 years. I graduated from Politecnico di Torino in 2021 with a Masters degree in Automotive Engineering, specializing in Propulsion Systems development. My masters thesis at General Motors comprised of developing a comprehensive methodology to perform virtual analysis on the main structural components of combustion engines (engine head and block) via fe-safe under the supervision of Dr. Cristiana Delprete. At the same time, I worked as a CFD Analyst at AEHRA during the prefeasibility analysis of their 2 exclusive models: Impeto and Estasi under the supervision of Filippo Perini. The aim was to define the DNA of the models through the development of a new car segment, aiming mainly at class-leading, high-performance aerodynamics and luxurious, next-generation ergonomics. After graduating, I felt the urge to work on the field, dealing with components and co-workers rather than just computers and screens. This is when I joined Dana Graziano as a Mechatronics Testing Engineer, working on the devlopment, verification, and validation of E-Axles and Hybrid DCTs. After 3.5 years, I decided to make my move to Germany where I’m currently working with Atesteo GmbH \u0026 Co. KG as an Engineering Project Manager. In this role, I’m responsible for discussing and understanding test specificaitons from different clients, preparing test benches with all necessary equipment and instrumentation (dynos, torquemeters, accelerometers, etc.), programming test cycles via Atesteo’s own automation system, and data management as well as post-processing in real-time and/or offline. ","date":"2012-07-23","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]